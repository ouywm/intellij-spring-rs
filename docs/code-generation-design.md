# 从数据库表生成 Sea-ORM 代码 — 功能设计文档

## 一、功能概述

类似 [MyBatisX](https://baomidou.com/en/guides/mybatis-x) 的"从表生成代码"功能。
用户在 IDE 的 Database 视图中选择表，自动生成 Rust sea-orm 实体代码，
以及可选的 DTO、VO、Service 层、Route 层代码。

**核心特点：**
- 使用 IDE 内置 DataSource（不需要用户手动配置连接）
- 支持自定义 Velocity 模板渲染
- 不使用模板时，使用内置默认模板生成
- 生成 5 种文件类型，每种可独立配置输出目录
- **配置持久化**：记住上次的所有选项，下次无需重复配置
- **可选第三方宏**：用户可勾选附加的 derive 宏（如 [bon](https://bon-rs.com/guide/overview)）

## 二、使用流程

```
1. 用户在 Database 视图中连接数据库（IDE 内置功能）
2. 右键选择一个或多个表 → "Generate Sea-ORM Code"
3. 弹出配置对话框：
   - 选择要生成的层（Entity / DTO / VO / Service / Route）
   - 配置每层的输出目录（独立配置）
   - 勾选附加 derive 宏
   - 选择模板（内置 or 自定义）
   - 预览生成代码
4. 点击 Generate → 文件写入项目
5. 所有配置自动保存，下次打开对话框时恢复
```

## 三、数据库接入方式

### 使用 IntelliJ Database Tools API

通过 `com.intellij.database` 插件 API 读取已配置的 DataSource：

```kotlin
// 获取选中的表（在 Database 视图右键菜单触发时）
val tables: List<DasTable> = ... // 从 AnActionEvent 中获取

// 读取表的列信息
val columns: JBIterable<DasColumn> = DasUtil.getColumns(table)
```

**依赖声明（plugin.xml）：**
```xml
<depends optional="true" config-file="database-features.xml">com.intellij.database</depends>
```

## 四、生成的代码结构（5 层）

### 4.1 Entity 层（必选）

sea-orm 实体结构体。基础 derive 宏（`Clone, Debug, PartialEq, Eq, DeriveEntityModel`）自动添加，
不需要用户选择。用户可以**额外勾选**第三方 derive 宏。

**示例：`entity/users.rs`**
```rust
//! `SeaORM` Entity. Generated by spring-rs plugin

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

/// 用户表
#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub username: String,
    pub email: String,
    pub avatar: Option<String>,          // Option<T> 已隐式表示 nullable
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

impl ActiveModelBehavior for ActiveModel {}
```

**`entity/mod.rs`：**
```rust
pub mod users;
pub mod posts;
```

**`entity/prelude.rs`：**
```rust
pub use super::users::Entity as Users;
pub use super::posts::Entity as Posts;
```

### 4.2 DTO 层（可选）

Data Transfer Object — 用于接收请求参数（创建/更新操作）。
不包含 `id`、`created_at`、`updated_at` 等自动生成的字段。

**示例：`dto/user_dto.rs`**
```rust
use serde::Deserialize;

/// 创建用户请求
#[derive(Debug, Deserialize)]
pub struct CreateUserDto {
    pub username: String,
    pub email: String,
    pub avatar: Option<String>,
}

/// 更新用户请求
#[derive(Debug, Deserialize)]
pub struct UpdateUserDto {
    pub username: Option<String>,
    pub email: Option<String>,
    pub avatar: Option<String>,
}
```

### 4.3 VO 层（可选）

View Object — 用于返回响应数据。可以选择性地排除敏感字段。

**示例：`vo/user_vo.rs`**
```rust
use serde::Serialize;

/// 用户响应
#[derive(Debug, Serialize)]
pub struct UserVo {
    pub id: i32,
    pub username: String,
    pub email: String,
    pub avatar: Option<String>,
    pub created_at: String,
}
```

### 4.4 Service 层（可选）

使用 spring-rs 的 `#[derive(Service)]` 模式，通过 `#[inject(component)]` 注入 `DbConn`。

> **注意：** `#[component]` 是 v0.3.0 之前的旧语法，新版使用 `#[inject(component)]`。

**示例：`service/user_service.rs`**
```rust
use crate::entity::users::{self, Entity as Users};
use crate::dto::user_dto::{CreateUserDto, UpdateUserDto};
use anyhow::Context;
use sea_orm::{ActiveModelTrait, ColumnTrait, EntityTrait, QueryFilter, Set};
use spring::plugin::service::Service;
use spring_sea_orm::DbConn;
use spring_web::error::Result;

#[derive(Clone, Service)]
pub struct UserService {
    #[inject(component)]
    db: DbConn,
}

impl UserService {
    pub async fn find_by_id(&self, id: i32) -> Result<Option<users::Model>> {
        Ok(Users::find_by_id(id)
            .one(&self.db)
            .await
            .context("query by id failed")?)
    }

    pub async fn find_all(&self) -> Result<Vec<users::Model>> {
        Ok(Users::find()
            .all(&self.db)
            .await
            .context("query all failed")?)
    }

    pub async fn create(&self, dto: CreateUserDto) -> Result<users::Model> {
        let model = users::ActiveModel {
            username: Set(dto.username),
            email: Set(dto.email),
            avatar: Set(dto.avatar),
            ..Default::default()
        };
        Ok(model.insert(&self.db).await.context("create failed")?)
    }

    pub async fn update(&self, id: i32, dto: UpdateUserDto) -> Result<users::Model> {
        let existing = Users::find_by_id(id)
            .one(&self.db)
            .await
            .context("query failed")?
            .context("not found")?;
        let mut model: users::ActiveModel = existing.into();
        if let Some(username) = dto.username { model.username = Set(username); }
        if let Some(email) = dto.email { model.email = Set(email); }
        if let Some(avatar) = dto.avatar { model.avatar = Set(Some(avatar)); }
        Ok(model.update(&self.db).await.context("update failed")?)
    }

    pub async fn delete_by_id(&self, id: i32) -> Result<()> {
        Users::delete_by_id(id)
            .exec(&self.db)
            .await
            .context("delete failed")?;
        Ok(())
    }
}
```

### 4.5 Route 层（可选）

通过 `Component<XxxService>` 注入 Service 层。

**示例：`route/user_route.rs`**
```rust
use crate::dto::user_dto::{CreateUserDto, UpdateUserDto};
use crate::service::user_service::UserService;
use spring_web::axum::response::IntoResponse;
use spring_web::delete;
use spring_web::error::Result;
use spring_web::extractor::{Component, Json, Path};
use spring_web::get;
use spring_web::post;
use spring_web::put;

#[get("/api/users")]
pub async fn list(
    Component(service): Component<UserService>,
) -> Result<impl IntoResponse> {
    let items = service.find_all().await?;
    Ok(Json(items))
}

#[get("/api/users/{id}")]
pub async fn get_by_id(
    Component(service): Component<UserService>,
    Path(id): Path<i32>,
) -> Result<impl IntoResponse> {
    let item = service.find_by_id(id).await?;
    Ok(Json(item))
}

#[post("/api/users")]
pub async fn create(
    Component(service): Component<UserService>,
    Json(dto): Json<CreateUserDto>,
) -> Result<impl IntoResponse> {
    let result = service.create(dto).await?;
    Ok(Json(result))
}

#[put("/api/users/{id}")]
pub async fn update(
    Component(service): Component<UserService>,
    Path(id): Path<i32>,
    Json(dto): Json<UpdateUserDto>,
) -> Result<impl IntoResponse> {
    let result = service.update(id, dto).await?;
    Ok(Json(result))
}

#[delete("/api/users/{id}")]
pub async fn delete(
    Component(service): Component<UserService>,
    Path(id): Path<i32>,
) -> Result<impl IntoResponse> {
    service.delete_by_id(id).await?;
    Ok(Json("deleted"))
}
```

## 五、SQL 类型 → Rust 类型映射

| SQL 类型 | Rust 类型 | 说明 |
|----------|-----------|------|
| INT / INTEGER / INT4 | `i32` | |
| BIGINT / INT8 | `i64` | |
| SMALLINT / INT2 | `i16` | |
| TINYINT | `i8` | MySQL |
| VARCHAR / TEXT / CHAR / CITEXT | `String` | |
| BOOLEAN / BOOL | `bool` | |
| FLOAT / REAL / FLOAT4 | `f32` | |
| DOUBLE / FLOAT8 | `f64` | |
| DECIMAL / NUMERIC | `Decimal` | 需要 `rust_decimal` |
| TIMESTAMP / TIMESTAMPTZ | `DateTimeWithTimeZone` | |
| TIMESTAMP WITHOUT TZ | `DateTime` | |
| DATE | `Date` | |
| TIME | `Time` | |
| UUID | `Uuid` | 需要 `uuid` feature |
| JSON / JSONB | `Json` | 需要 `serde_json` |
| BYTEA / BLOB / BINARY | `Vec<u8>` | |
| ARRAY | `Vec<T>` | PostgreSQL 数组 |
| nullable 列 | `Option<T>` | 自动包装 |

## 六、可选第三方 Derive 宏

### 6.1 宏分类

**基础宏（自动添加，不可去除）：**
- Entity: `Clone, Debug, PartialEq, Eq, DeriveEntityModel`
- DTO: `Debug, Deserialize`
- VO: `Debug, Serialize`
- Service: `Clone, Service`

**常用可选宏（复选框勾选）：**

| 宏名 | 来源 crate | 适用层 | 说明 |
|------|-----------|--------|------|
| `Serialize` | serde | Entity/VO | 序列化 |
| `Deserialize` | serde | Entity/DTO | 反序列化 |
| `Builder` | [bon](https://bon-rs.com/guide/overview) | Entity/DTO/VO | 编译时 Builder 模式 |
| `Default` | std | Entity/DTO/VO | 默认值 |
| `Hash` | std | Entity/VO | 可哈希 |
| `PartialOrd, Ord` | std | Entity | 可排序 |
| `JsonSchema` | schemars | Entity/DTO/VO | JSON Schema 生成 |
| `Validate` | validator | DTO | 字段校验 |

### 6.2 配置 UI

在对话框中每个层下方显示复选框区域：

```
── Entity Layer ────────────────────────────────
☑ Generate Entity
Output Directory: [src/entity] ........... [Browse]
Additional Derives:
  ☑ Serialize, Deserialize (serde)
  ☐ Builder (bon)
  ☐ Default
  ☐ Hash
  ☐ JsonSchema (schemars)
```

## 七、模板系统

### 7.1 模板引擎

使用 **Apache Velocity**（IntelliJ 平台内置）。

### 7.2 模板变量（Velocity Context）

| 变量 | 类型 | 说明 |
|------|------|------|
| `$tableName` | String | 原始表名 |
| `$tableComment` | String | 表注释 |
| `$entityName` | String | PascalCase（如 `UserAccounts`） |
| `$moduleName` | String | snake_case（如 `user_accounts`） |
| `$serviceName` | String | Service 名（如 `UserAccountsService`） |
| `$dtoCreateName` | String | 创建 DTO 名（如 `CreateUserAccountsDto`） |
| `$dtoUpdateName` | String | 更新 DTO 名（如 `UpdateUserAccountsDto`） |
| `$voName` | String | VO 名（如 `UserAccountsVo`） |
| `$columns` | List | 全部列 |
| `$insertColumns` | List | 可插入列（排除 PK auto_increment、created_at 等） |
| `$updateColumns` | List | 可更新列（排除 PK、created_at、updated_at 等） |
| `$column.name` | String | 列名 |
| `$column.fieldName` | String | Rust 字段名 |
| `$column.rustType` | String | Rust 类型 |
| `$column.sqlType` | String | SQL 类型 |
| `$column.isPrimaryKey` | Boolean | 是否主键 |
| `$column.isNullable` | Boolean | 是否可空 |
| `$column.isAutoIncrement` | Boolean | 是否自增 |
| `$column.comment` | String | 列注释 |
| `$primaryKeyType` | String | 主键 Rust 类型 |
| `$primaryKeyName` | String | 主键列名 |
| `$routePrefix` | String | 路由前缀 |
| `$extraDerives` | String | 额外 derive 宏（逗号分隔） |
| `$addSerde` | Boolean | 是否添加 serde |
| `$addBon` | Boolean | 是否添加 bon Builder |

### 7.3 自定义模板目录

```
项目根目录/
└── .spring-rs/
    └── templates/
        ├── entity.rs.vm
        ├── dto.rs.vm
        ├── vo.rs.vm
        ├── service.rs.vm
        └── route.rs.vm
```

**加载优先级：** 项目 `.spring-rs/templates/` → 内置默认模板

### 7.4 内置模板位置

```
src/main/resources/fileTemplates/internal/
├── sea-orm-entity.rs.vm
├── sea-orm-dto.rs.vm
├── sea-orm-vo.rs.vm
├── sea-orm-service.rs.vm
└── sea-orm-route.rs.vm
```

## 八、配置持久化

使用 IntelliJ 的 `PersistentStateComponent` 保存用户选择，下次打开对话框自动恢复。

### 8.1 持久化的配置项

```kotlin
@State(
    name = "SpringRsCodeGenSettings",
    storages = [Storage("springRsCodeGen.xml")]
)
class CodeGenSettingsState : PersistentStateComponent<CodeGenSettingsState> {
    // ── 层开关 ──
    var generateEntity: Boolean = true
    var generateDto: Boolean = true
    var generateVo: Boolean = false
    var generateService: Boolean = true
    var generateRoute: Boolean = true

    // ── 输出目录 ──
    var entityOutputDir: String = "src/entity"
    var dtoOutputDir: String = "src/dto"
    var voOutputDir: String = "src/vo"
    var serviceOutputDir: String = "src/service"
    var routeOutputDir: String = "src/route"

    // ── 路由前缀 ──
    var routePrefix: String = "/api"

    // ── 可选 derive 宏 ──
    var entityExtraDerives: MutableSet<String> = mutableSetOf("Serialize", "Deserialize")
    var dtoExtraDerives: MutableSet<String> = mutableSetOf()
    var voExtraDerives: MutableSet<String> = mutableSetOf()

    // ── 模板 ──
    var useCustomTemplate: Boolean = false
    var customTemplatePath: String = ".spring-rs/templates"
}
```

### 8.2 存储位置

项目级：`.idea/springRsCodeGen.xml`

## 九、UI 设计

### 9.1 生成对话框

```
┌──────────────── Generate Sea-ORM Code ─────────────────────┐
│                                                              │
│  Selected Tables: users, posts, comments                     │
│                                                              │
│ ┌─ Entity ────────────────────────────────────────────────┐  │
│ │ ☑ Generate Entity                                       │  │
│ │ Dir: [src/entity] ............................ [Browse]  │  │
│ │ Extra Derives:                                          │  │
│ │   ☑ Serialize, Deserialize    ☐ Builder (bon)           │  │
│ │   ☐ Default                   ☐ JsonSchema              │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                              │
│ ┌─ DTO ──────────────────────────────────────────────────┐   │
│ │ ☑ Generate DTO (CreateXxxDto + UpdateXxxDto)           │   │
│ │ Dir: [src/dto] ............................... [Browse] │   │
│ │ Extra Derives:                                         │   │
│ │   ☐ Builder (bon)            ☐ Validate (validator)    │   │
│ └────────────────────────────────────────────────────────┘   │
│                                                              │
│ ┌─ VO ───────────────────────────────────────────────────┐   │
│ │ ☐ Generate VO                                          │   │
│ │ Dir: [src/vo] ................................ [Browse] │   │
│ │ Extra Derives:                                         │   │
│ │   ☐ Builder (bon)            ☐ JsonSchema              │   │
│ └────────────────────────────────────────────────────────┘   │
│                                                              │
│ ┌─ Service ──────────────────────────────────────────────┐   │
│ │ ☑ Generate Service (#[derive(Service)])                │   │
│ │ Dir: [src/service] .......................... [Browse]  │   │
│ └────────────────────────────────────────────────────────┘   │
│                                                              │
│ ┌─ Route ────────────────────────────────────────────────┐   │
│ │ ☑ Generate Route (CRUD handlers)                       │   │
│ │ Dir: [src/route] ........................... [Browse]   │   │
│ │ Prefix: [/api] ..................                       │   │
│ └────────────────────────────────────────────────────────┘   │
│                                                              │
│ ┌─ Template ─────────────────────────────────────────────┐   │
│ │ ○ Use built-in templates                               │   │
│ │ ● Use custom templates                                 │   │
│ │ Dir: [.spring-rs/templates] ................ [Browse]   │   │
│ └────────────────────────────────────────────────────────┘   │
│                                                              │
│                       [Cancel]  [Preview]  [Generate]        │
└──────────────────────────────────────────────────────────────┘
```

### 9.2 预览对话框

点击 [Preview] 后弹出：左侧为文件树，右侧为代码预览（带语法高亮）。

## 十、模块划分

| 包路径 | 文件 | 职责 |
|--------|------|------|
| `codegen/` | `GenerateSeaOrmAction.kt` | Action 入口（右键菜单） |
| `codegen/` | `GenerateSeaOrmDialog.kt` | 配置对话框 UI |
| `codegen/` | `CodePreviewDialog.kt` | 代码预览对话框 |
| `codegen/` | `CodeGenSettingsState.kt` | 配置持久化（PersistentStateComponent） |
| `codegen/` | `TableMetadataReader.kt` | 从 DasTable 读取表/列元数据 |
| `codegen/` | `SqlTypeMapper.kt` | SQL 类型 → Rust 类型映射 |
| `codegen/` | `SeaOrmEntityGenerator.kt` | Entity 代码生成 |
| `codegen/` | `DtoGenerator.kt` | DTO 代码生成 |
| `codegen/` | `VoGenerator.kt` | VO 代码生成 |
| `codegen/` | `ServiceGenerator.kt` | Service 层代码生成 |
| `codegen/` | `RouteGenerator.kt` | Route 层代码生成 |
| `codegen/` | `VelocityTemplateEngine.kt` | Velocity 模板渲染引擎 |

## 十一、数据模型

```kotlin
/** 表元数据 */
data class TableInfo(
    val name: String,
    val comment: String?,
    val columns: List<ColumnInfo>,
    val primaryKeys: List<String>
) {
    /** PascalCase 实体名 */
    val entityName: String get() = name.toPascalCase()
    /** snake_case 模块名 */
    val moduleName: String get() = name.toSnakeCase()
    /** Service 类名 */
    val serviceName: String get() = "${entityName}Service"
    /** DTO 类名 */
    val dtoCreateName: String get() = "Create${entityName}Dto"
    val dtoUpdateName: String get() = "Update${entityName}Dto"
    /** VO 类名 */
    val voName: String get() = "${entityName}Vo"

    /** 可插入列（排除自增主键、created_at 等） */
    val insertColumns: List<ColumnInfo> get() = columns.filter {
        !it.isAutoIncrement && it.name !in EXCLUDED_INSERT_COLUMNS
    }
    /** 可更新列（排除主键、created_at、updated_at） */
    val updateColumns: List<ColumnInfo> get() = columns.filter {
        !it.isPrimaryKey && it.name !in EXCLUDED_UPDATE_COLUMNS
    }

    companion object {
        val EXCLUDED_INSERT_COLUMNS = setOf("created_at", "updated_at", "create_time", "update_time")
        val EXCLUDED_UPDATE_COLUMNS = setOf("id", "created_at", "create_time")
    }
}

/** 列元数据 */
data class ColumnInfo(
    val name: String,
    val sqlType: String,
    val rustType: String,
    val isPrimaryKey: Boolean,
    val isNullable: Boolean,
    val isAutoIncrement: Boolean,
    val comment: String?,
    val defaultValue: String?
) {
    /** Rust 字段名（snake_case，处理关键字） */
    val fieldName: String get() {
        val snake = name.toSnakeCase()
        return if (snake in RUST_KEYWORDS) "r#$snake" else snake
    }
}
```

## 十二、plugin.xml 依赖

```xml
<!-- Database Tools: optional for code generation -->
<depends optional="true" config-file="database-features.xml">com.intellij.database</depends>
```

`database-features.xml`：
```xml
<idea-plugin>
    <actions>
        <action id="SpringRs.GenerateSeaOrm"
                class="com.springrs.plugin.codegen.GenerateSeaOrmAction"
                text="Generate Sea-ORM Code"
                description="Generate sea-orm entity, DTO, VO, service, route from database tables"
                icon="/icons/spring-rs.svg">
            <add-to-group group-id="DatabaseViewPopupMenu" anchor="last"/>
        </action>
    </actions>
</idea-plugin>
```

## 十三、开发优先级

### Phase 1（MVP）
- [ ] `TableMetadataReader` + `SqlTypeMapper`
- [ ] `SeaOrmEntityGenerator`（内置模板）
- [ ] `GenerateSeaOrmAction`（右键菜单入口）
- [ ] `GenerateSeaOrmDialog`（基础对话框）
- [ ] `CodeGenSettingsState`（配置持久化）
- [ ] PostgreSQL 支持

### Phase 2（完善）
- [ ] `DtoGenerator` + `VoGenerator`
- [ ] `ServiceGenerator` + `RouteGenerator`
- [ ] `VelocityTemplateEngine`（自定义模板支持）
- [ ] 可选 derive 宏复选框
- [ ] `CodePreviewDialog`（预览）
- [ ] MySQL / SQLite 支持

### Phase 3（增强）
- [ ] 关联关系自动检测（外键 → has_one / has_many / belongs_to，见第十四节）
- [ ] 增量生成（只更新变化的列，不覆盖用户修改）
- [ ] mod.rs 智能更新（追加新模块，不覆盖已有内容）
- [ ] 模板组（Template Group）支持，类似 EasyCode 的多套模板切换
- [ ] 表名/列名自定义映射规则（正则替换，如去除表前缀 `t_`）
- [ ] 每张表独立配置（排除指定列、自定义类名等）

## 十四、关联关系自动检测

参考 [sea-orm 关联关系](https://www.sea-ql.org/SeaORM/docs/relation/one-to-many/) 和
[JPA Buddy](https://jpa-buddy.com/guides/generate-or-synchronize-jpa-hibernate-entities/) 的设计。

### 14.1 检测规则

通过数据库外键信息自动推断关联类型：

| 外键情况 | 生成的关联 | 说明 |
|----------|-----------|------|
| A.user_id → B.id（无唯一约束） | A: `belongs_to` B, B: `has_many` A | 一对多 |
| A.profile_id → B.id（有唯一约束） | A: `belongs_to` B, B: `has_one` A | 一对一 |
| 中间表 A_B(a_id, b_id) | A: `has_many via A_B`, B: `has_many via A_B` | 多对多 |

### 14.2 生成示例

sea-orm 2.0 的关联关系需要：`Model` 中的关系字段 + `Relation` 枚举 + `Related` trait impl。

**users.rs（有 has_many posts 和 has_one profile）：**
```rust
use sea_orm::entity::prelude::*;

#[sea_orm::model]
#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub username: String,
    #[sea_orm(has_many)]
    pub posts: HasMany<super::posts::Entity>,
    #[sea_orm(has_one)]
    pub profile: HasOne<super::profiles::Entity>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::posts::Entity")]
    Posts,
    #[sea_orm(has_one = "super::profiles::Entity")]
    Profile,
}

impl Related<super::posts::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Posts.def()
    }
}

impl Related<super::profiles::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Profile.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

**posts.rs（belongs_to users）：**
```rust
use sea_orm::entity::prelude::*;

#[sea_orm::model]
#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "posts")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub user_id: i32,
    pub title: String,
    #[sea_orm(belongs_to, from = "user_id", to = "id")]
    pub author: HasOne<super::users::Entity>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::users::Entity",
        from = "Column::UserId",
        to = "super::users::Column::Id"
    )]
    User,
}

impl Related<super::users::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
```

**多对多（通过中间表）：**
```rust
// post_tags.rs (junction table)
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::posts::Entity",
        from = "Column::PostId",
        to = "super::posts::Column::Id"
    )]
    Post,
    #[sea_orm(
        belongs_to = "super::tags::Entity",
        from = "Column::TagId",
        to = "super::tags::Column::Id"
    )]
    Tag,
}
```

## 十五、表名前缀处理

参考 [EasyCode](https://gitee.com/laiyefei/EasyCode.git) 的列名映射功能。

### 15.1 常见需求

很多项目的表名有统一前缀（如 `t_user`、`sys_config`），生成实体时需要去掉前缀。

### 15.2 配置项

```kotlin
// 在 CodeGenSettingsState 中增加
var tableNamePrefix: String = ""  // 要去掉的表名前缀，如 "t_"、"sys_"
var columnNamePrefix: String = "" // 要去掉的列名前缀，如 "f_"
```

### 15.3 处理逻辑

- 表 `t_user` + prefix `t_` → Entity 名 `User`，模块名 `user`
- 表 `sys_config` + prefix `sys_` → Entity 名 `Config`，模块名 `config`
- `table_name` 属性仍保留原始表名：`#[sea_orm(table_name = "t_user")]`

## 十六、每张表独立配置

### 16.1 需求

批量生成时，用户可能需要对个别表做特殊处理：
- 排除某些列不生成（如内部审计字段 `internal_note`）
- 自定义实体名（表 `tbl_usr` → 希望生成 `User` 而不是 `TblUsr`）
- 某张表不生成 Service/Route（只要 Entity）

### 16.2 UI 设计

在对话框的表列表区域，每张表右侧增加 `[配置]` 按钮，点击弹出该表的独立配置面板：

```
┌────── Table: t_user_accounts ──────────────────┐
│                                                  │
│  Entity Name: [UserAccounts]  (可手动修改)       │
│  Module Name: [user_accounts] (自动生成)         │
│                                                  │
│  Columns:                                        │
│  ☑ id           i32     (PK, auto_increment)    │
│  ☑ username     String                           │
│  ☑ email        String                           │
│  ☐ internal_note String  ← 取消勾选 = 排除       │
│  ☑ created_at   DateTimeWithTimeZone             │
│  ☑ updated_at   DateTimeWithTimeZone             │
│                                                  │
│  Generate Layers:                                │
│  ☑ Entity  ☑ DTO  ☐ VO  ☑ Service  ☑ Route     │
│                                                  │
│                          [Cancel]  [OK]          │
└──────────────────────────────────────────────────┘
```

### 16.3 数据模型

```kotlin
/** 每张表的独立配置 */
data class TableOverrideConfig(
    val tableName: String,
    var customEntityName: String? = null,    // 自定义实体名（null = 自动推断）
    var excludedColumns: MutableSet<String> = mutableSetOf(),  // 排除的列名
    var generateEntity: Boolean = true,
    var generateDto: Boolean = true,
    var generateVo: Boolean = false,
    var generateService: Boolean = true,
    var generateRoute: Boolean = true
)
```

在 `CodeGenSettingsState` 中持久化：

```kotlin
// 每张表的独立配置（key = 表名）
var tableOverrides: MutableMap<String, TableOverrideConfig> = mutableMapOf()
```

### 16.4 生效逻辑

```
全局配置（对话框主面板）
    └── 表级配置覆盖（每张表的 [配置] 面板）
        └── 最终生成参数
```

- 表级 `customEntityName` 不为 null 时，覆盖全局的前缀去除规则
- 表级 `excludedColumns` 中的列不会出现在生成的 Entity/DTO/VO 中
- 表级 `generateXxx` 覆盖全局的层开关

## 十七、增量生成

### 17.1 问题

用户生成代码后可能手动修改了文件（如添加自定义方法、修改字段类型）。
再次生成时不应覆盖这些修改。

### 17.2 策略

| 文件类型 | 策略 | 说明 |
|----------|------|------|
| Entity (`users.rs`) | **标记区域保护** | 自动生成的代码用标记注释包裹，只更新标记内的内容 |
| DTO (`user_dto.rs`) | **不覆盖已有文件** | 如果文件存在，提示用户选择（跳过 / 覆盖 / 合并） |
| VO (`user_vo.rs`) | **不覆盖已有文件** | 同上 |
| Service (`user_service.rs`) | **不覆盖已有文件** | 同上 |
| Route (`user_route.rs`) | **不覆盖已有文件** | 同上 |
| `mod.rs` | **智能追加** | 见第十八节 |

### 17.3 标记区域（Entity 文件）

```rust
// === spring-rs generated START ===
// DO NOT EDIT between these markers. Re-generate to update.

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "users")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub username: String,
    pub email: String,
}

impl ActiveModelBehavior for ActiveModel {}

// === spring-rs generated END ===

// 用户可以在标记外面添加自定义代码，不会被覆盖
impl Model {
    pub fn display_name(&self) -> String {
        format!("{}({})", self.username, self.email)
    }
}
```

再次生成时，只替换 `START` 和 `END` 之间的内容。标记外的用户代码保留。

### 17.4 文件冲突对话框

当目标文件已存在且不包含标记时，弹出冲突处理对话框：

```
┌──── File Exists ──────────────────────────────────┐
│                                                    │
│  File already exists: src/service/user_service.rs  │
│                                                    │
│  ○ Skip (keep existing file)                       │
│  ○ Overwrite (replace with generated code)         │
│  ○ Backup & Overwrite (rename old to .bak)         │
│                                                    │
│  ☑ Apply to all conflicting files                  │
│                                                    │
│                         [Cancel]  [OK]             │
└────────────────────────────────────────────────────┘
```

## 十八、mod.rs 智能更新

### 18.1 问题

每次生成新表的 Entity 时需要在 `mod.rs` 中添加 `pub mod xxx;`。
不能直接覆盖 `mod.rs`，否则之前的模块声明会丢失。

### 18.2 策略

1. **读取现有 `mod.rs`**（如果存在）
2. **解析已有的 `pub mod xxx;` 声明**
3. **追加新的模块声明**（去重）
4. **按字母排序**
5. **写回文件**

### 18.3 示例

**生成前 `mod.rs`：**
```rust
pub mod users;
pub mod posts;
```

**新增表 `comments` 和 `tags` 后：**
```rust
pub mod comments;  // ← 新增
pub mod posts;
pub mod tags;      // ← 新增
pub mod users;
```

### 18.4 prelude.rs 同理

```rust
// 生成前
pub use super::users::Entity as Users;
pub use super::posts::Entity as Posts;

// 新增后（追加 + 排序）
pub use super::comments::Entity as Comments;
pub use super::posts::Entity as Posts;
pub use super::tags::Entity as Tags;
pub use super::users::Entity as Users;
```

### 18.5 实现

```kotlin
fun updateModFile(modFilePath: Path, newModules: List<String>) {
    val existingContent = if (modFilePath.exists()) modFilePath.readText() else ""
    
    // 解析已有模块
    val existingModules = Regex("""pub\s+mod\s+(\w+)\s*;""")
        .findAll(existingContent)
        .map { it.groupValues[1] }
        .toMutableSet()
    
    // 合并新模块
    existingModules.addAll(newModules)
    
    // 排序后写回
    val sorted = existingModules.sorted()
    val newContent = sorted.joinToString("\n") { "pub mod $it;" } + "\n"
    modFilePath.writeText(newContent)
}
```
