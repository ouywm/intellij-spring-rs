package com.springrs.plugin.codegen

import com.intellij.database.model.DasTable
import com.intellij.database.util.DasUtil
import com.springrs.plugin.codegen.dialect.DatabaseDialect

/**
 * Reads table metadata from IntelliJ Database Tools API (DasTable).
 *
 * Uses [DatabaseDialect] for database-specific SQL → Rust type mapping.
 */
object TableMetadataReader {

    /**
     * Read metadata for a single table, auto-detecting the database dialect.
     */
    fun readTable(table: DasTable): TableInfo {
        val dialect = DatabaseDialect.detect(table)
        return readTable(table, dialect)
    }

    /**
     * Read metadata for a single table using the specified dialect.
     */
    fun readTable(
        table: DasTable,
        dialect: DatabaseDialect,
        tableNamePrefix: String = "",
        columnNamePrefix: String = ""
    ): TableInfo {
        val primaryKeyNames = mutableListOf<String>()
        DasUtil.getPrimaryKey(table)?.let { pk ->
            pk.columnsRef.names().forEach { primaryKeyNames.add(it) }
        }

        // Collect single-column UNIQUE constraints (excluding PK columns)
        val uniqueColumnNames = mutableSetOf<String>()
        for (index in DasUtil.getIndices(table)) {
            if (index.isUnique) {
                val cols = index.columnsRef.names().toList()
                if (cols.size == 1 && cols.first() !in primaryKeyNames) {
                    uniqueColumnNames.add(cols.first())
                }
            }
        }

        // Read PostgreSQL schema name from parent container
        val schemaName = table.dasParent?.name ?: ""

        val columns = mutableListOf<ColumnInfo>()
        for (col in DasUtil.getColumns(table)) {
            // Prefer specification (includes precision, e.g., "numeric(20,6)", "timestamptz(3)")
            // over typeClass.name (just base name, e.g., "numeric", "timestamptz").
            // This ensures Decimal precision, Float/Double annotations, and timestamp timezone
            // info are correctly preserved for sea-orm column_type generation.
            val sqlType = col.dasType.specification.takeIf { it.isNotBlank() }
                ?: col.dasType.typeClass.name
            val isPk = col.name in primaryKeyNames
            val isNullable = !col.isNotNull && !isPk

            // Auto-increment detection: DasUtil + SQL type fallback
            // DasUtil.isAutoGenerated() may return false for PG SERIAL types,
            // especially in non-public schemas. Fall back to type name / default value.
            val isAutoIncrement = DasUtil.isAutoGenerated(col)
                || isSerialType(sqlType)
                || isSequenceDefault(col.default)

            columns.add(
                ColumnInfo(
                    name = col.name,
                    sqlType = sqlType,
                    rustType = dialect.toRustType(sqlType),
                    isPrimaryKey = isPk,
                    isNullable = isNullable,
                    isAutoIncrement = isAutoIncrement,
                    comment = col.comment,
                    defaultValue = col.default,
                    isUnique = col.name in uniqueColumnNames
                )
            )
        }

        return TableInfo(
            name = table.name,
            comment = table.comment,
            columns = columns,
            primaryKeys = primaryKeyNames,
            tableNamePrefix = tableNamePrefix,
            columnNamePrefix = columnNamePrefix,
            schemaName = schemaName
        )
    }

    /**
     * Read metadata for multiple tables, auto-detecting dialect from the first table.
     */
    fun readTables(tables: List<DasTable>): List<TableInfo> {
        if (tables.isEmpty()) return emptyList()
        val dialect = DatabaseDialect.detect(tables.first())
        return tables.map { readTable(it, dialect) }
    }

    // ── Auto-increment detection helpers ──

    /** PG SERIAL types are auto-increment by definition. */
    private val SERIAL_TYPES = setOf("serial", "serial4", "bigserial", "serial8", "smallserial", "serial2")

    private fun isSerialType(sqlType: String): Boolean =
        sqlType.trim().lowercase() in SERIAL_TYPES

    /** PG SERIAL columns have default like `nextval('table_id_seq'::regclass)`. */
    private fun isSequenceDefault(defaultValue: String?): Boolean =
        defaultValue?.lowercase()?.contains("nextval(") == true
}
