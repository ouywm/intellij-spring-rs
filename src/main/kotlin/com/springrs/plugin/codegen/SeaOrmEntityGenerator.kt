package com.springrs.plugin.codegen

import com.intellij.openapi.project.Project
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_CLONE
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_DEBUG
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_DESERIALIZE
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_EQ
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_PARTIAL_EQ
import com.springrs.plugin.utils.SpringRsConstants.DERIVE_SERIALIZE
import com.springrs.plugin.utils.SpringRsConstants.SEA_ORM_DERIVE_ENTITY_MODEL
import com.springrs.plugin.utils.SpringRsConstants.SEA_ORM_DERIVE_RELATION
import com.springrs.plugin.utils.SpringRsConstants.SEA_ORM_ENUM_ITER
import com.springrs.plugin.utils.SpringRsConstants.TYPE_DECIMAL

/**
 * Generates sea-orm Entity code from table metadata.
 *
 * Two modes:
 * - [generate]: Velocity template (primary) with string-building fallback
 * - [generateEntity]: Pure string-building (fallback, no project context needed)
 */
object SeaOrmEntityGenerator {

    /** Base derives for Entity struct (always present). */
    val ENTITY_BASE_DERIVES = listOf(DERIVE_CLONE, DERIVE_DEBUG, DERIVE_PARTIAL_EQ, DERIVE_EQ, SEA_ORM_DERIVE_ENTITY_MODEL)

    /**
     * Primary generation entry point — uses Velocity template, falls back to string building.
     *
     * @param relations  Detected foreign key relations for this table (from [RelationDetector]).
     */
    fun generate(
        table: TableInfo,
        extraDerives: Set<String>,
        project: Project,
        relations: List<RelationInfo> = emptyList()
    ): String {
        return try {
            val settings = CodeGenSettingsState.getInstance(project)
            val template = VelocityTemplateEngine.loadTemplate(
                project, "entity", settings.useCustomTemplate, settings.customTemplatePath
            )
            val context = VelocityTemplateEngine.buildTableContext(table, settings, relations)
            val extras = extraDerives.filter { it !in ENTITY_BASE_DERIVES }
            context["baseDerives"] = ENTITY_BASE_DERIVES.joinToString(", ")
            context["extraDerives"] = extras.joinToString(", ")
            context["addSerde"] = DERIVE_SERIALIZE in extraDerives || DERIVE_DESERIALIZE in extraDerives
            context["needsDecimal"] = table.columns.any { it.rustType == TYPE_DECIMAL }
            VelocityTemplateEngine.render(template, context)
        } catch (_: Exception) {
            generateEntity(table, extraDerives)
        }
    }

    /** Generated file name: `{module_name}.rs` */
    fun fileName(table: TableInfo): String = "${table.moduleName}.rs"

    /** Module name for mod.rs */
    fun modName(table: TableInfo): String = table.moduleName

    /**
     * String-building fallback — no project / template engine dependency.
     */
    fun generateEntity(table: TableInfo, extraDerives: Set<String> = emptySet()): String {
        val sb = StringBuilder()

        sb.appendLine("//! `SeaORM` Entity. Generated by spring-rs plugin")
        sb.appendLine()
        sb.appendLine("use sea_orm::entity::prelude::*;")

        val needsSerde = DERIVE_SERIALIZE in extraDerives || DERIVE_DESERIALIZE in extraDerives
        if (needsSerde) {
            val serdeImports = buildList {
                if (DERIVE_DESERIALIZE in extraDerives) add(DERIVE_DESERIALIZE)
                if (DERIVE_SERIALIZE in extraDerives) add(DERIVE_SERIALIZE)
            }
            sb.appendLine("use serde::{${serdeImports.joinToString(", ")}};")
        }

        if (table.columns.any { it.rustType == TYPE_DECIMAL }) {
            sb.appendLine("use rust_decimal::Decimal;")
        }

        sb.appendLine()

        if (!table.comment.isNullOrBlank()) {
            sb.appendLine("/// ${table.comment}")
        }

        val extras = extraDerives.filter { it !in ENTITY_BASE_DERIVES }
        sb.appendLine("#[derive(${(ENTITY_BASE_DERIVES + extras).joinToString(", ")})]")
        sb.appendLine("#[sea_orm(table_name = \"${table.name}\")]")
        sb.appendLine("pub struct Model {")

        for (col in table.columns) {
            if (!col.comment.isNullOrBlank()) {
                sb.appendLine("    /// ${col.comment}")
            }
            if (col.isPrimaryKey) {
                val attr = if (col.isAutoIncrement) "primary_key" else "primary_key, auto_increment = false"
                sb.appendLine("    #[sea_orm($attr)]")
            }
            sb.appendLine("    pub ${col.fieldName}: ${col.fullRustType},")
        }

        sb.appendLine("}")
        sb.appendLine()
        sb.appendLine("#[derive(Copy, $DERIVE_CLONE, $DERIVE_DEBUG, $SEA_ORM_ENUM_ITER, $SEA_ORM_DERIVE_RELATION)]")
        sb.appendLine("pub enum Relation {}")
        sb.appendLine()
        sb.appendLine("impl ActiveModelBehavior for ActiveModel {}")

        return sb.toString()
    }

    /** Generate `mod.rs` content, includes `prelude`. */
    fun generateModRs(modules: List<String>): String {
        return (modules + "prelude").distinct().sorted().joinToString("\n") { "pub mod $it;" } + "\n"
    }

    /** Generate `prelude.rs` with re-exports. */
    fun generatePreludeRs(tables: List<TableInfo>): String {
        return tables.sortedBy { it.moduleName }
            .joinToString("\n") { "pub use super::${it.moduleName}::Entity as ${it.entityName};" } + "\n"
    }
}
