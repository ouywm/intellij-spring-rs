use sea_orm::entity::prelude::*;
#if($addSerde)
use serde::{Deserialize, Serialize};
#end
#if($addBon)
use bon::Builder;
#end
#if($addJsonSchema)
use schemars::JsonSchema;
#end
#if($needsDecimal)
use rust_decimal::Decimal;
#end
#if($hasTimestamps)
use chrono::Utc;
use sea_orm::Set;
#end

#if($tableComment != "")

/// $tableComment
///
/// Table: `${tableName}`
#else

/// Entity for table `${tableName}`
#end

#[derive(${baseDerives}#if($extraDerives != ""), ${extraDerives}#end)]
#if($hasSchema)
#[sea_orm(schema_name = "$schemaName", table_name = "$tableName")]
#else
#[sea_orm(table_name = "$tableName")]
#end
pub struct Model {
#foreach($column in $columns)
#if($column.comment != "")
    /// $column.comment
#end
#if($column.isVirtual)
    #[sea_orm(ignore)]
#elseif($column.hasSeaOrmAttr)
    #[sea_orm($column.seaOrmAttr)]
#end
    pub $column.fieldName: $column.fullRustType,
#end
}

#if($hasRelations)
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
#foreach($rel in $relations)
#if($rel.isBelongsTo)
    #[sea_orm(
        belongs_to = "$rel.targetEntityPath",
        from = "$rel.fromColumnPath",
        to = "$rel.toColumnPath"
    )]
    $rel.variantName,
#elseif($rel.isHasMany)
    #[sea_orm(has_many = "$rel.targetEntityPath")]
    $rel.variantName,
#elseif($rel.isHasOne)
    #[sea_orm(has_one = "$rel.targetEntityPath")]
    $rel.variantName,
#end
#end
}

## Deduplicate impl Related by target entity (same target can only have one impl)
#set($emittedTargets = $tool.newHashSet())
#foreach($rel in $relations)
#if(!$emittedTargets.contains($rel.targetEntityPath))
#set($added = $emittedTargets.add($rel.targetEntityPath))
impl Related<$rel.targetEntityPath> for Entity {
    fn to() -> RelationDef {
        Relation::${rel.variantName}.def()
    }
}

#end
#end
#else
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

#end
#if($hasTimestamps)
#[async_trait::async_trait]
impl ActiveModelBehavior for ActiveModel {
    /// Auto-set timestamps before insert/update
#if($hasCreatedAt)
    async fn before_save<C>(mut self, _db: &C, insert: bool) -> Result<Self, DbErr>
#else
    async fn before_save<C>(mut self, _db: &C, _insert: bool) -> Result<Self, DbErr>
#end
    where
        C: ConnectionTrait,
    {
        let now = ${timestampNowExpr};
#if($hasCreatedAt)
        if insert {
            self.$createdAtFieldName = Set(now);
        }
#end
#if($hasUpdatedAt)
        self.$updatedAtFieldName = Set(now);
#end
        Ok(self)
    }
}
#else
impl ActiveModelBehavior for ActiveModel {}
#end
